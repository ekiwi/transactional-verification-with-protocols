#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import subprocess, re, os, tempfile, shutil

from .module import Module, ArraySignal
from .bounded import Model

def require_verilator() -> str:
	r = subprocess.run(['verilator --version'], stdout=subprocess.PIPE, shell=True)
	assert r.returncode == 0, f"Failed to find verilator! {r}"
	version = re.match(r'Verilator (\d+\.\d+)', r.stdout.decode('utf-8')).group(1)
	return version


_top_hpp_template = """
// this is an example top.hpp
// in reality it will be autogenerated by a python script

#include <V{name}.h>
#include <V{name}__Syms.h>
#define TOP_TYPE V{name}
#define TOP_CLK {clock}

TOP_TYPE* top = nullptr;


static void set(const std::string& name, const std::string& num_str) {{
	uint64_t value = std::stoll(num_str);
	if(false) {{}}
{sett}
	else {{
		throw new std::runtime_error("Not an input or register: " + name);
	}}
}}
"""

def find_clock(top: Module):
	inputs = set(top.inputs.keys())
	candidates =  ["clock", "clk"]
	for name in candidates:
		if name in inputs:
			return name
	for name in candidates:
		for ii in inputs:
			if name in ii:
				return ii
	raise RuntimeError(f"Failed ot find clock of {top.name} in {inputs} (candidates: {candidates})")

def to_verilator_name(top: Module, st) -> str:
	parts = [top.name] + st.name.split('.')
	# TODO: remove terrible hack
	#parts = [pp[2:] if pp.startswith("o_") else pp for pp in parts]
	return "->".join(parts)

def top_hpp(top: Module):
	clk = find_clock(top)
	# filter out clock input and inputs to blackboxed submodules (which start with __EXP)
	inputs = [ii for ii in top.inputs.keys() if ii != clk and not ii.startswith('__')]
	set_lines = [f"\telse if(name == \"{name}\") {{ top->{name} = value; }}" for name in inputs]
	registers = [st.name for st in top.state.values() if not isinstance(st, ArraySignal)]
	state = [(st.name, to_verilator_name(top, st))
			 for st in top.state.values() if not isinstance(st, ArraySignal)]
	set_lines += [f"\telse if(name == \"{name}\") {{ assert(step0); top->{prop} = value; }}" for name, prop in state]
	sett = '\n'.join(set_lines)
	return _top_hpp_template.format(name=top.name, clock=clk, sett=sett)

def patch_verlog(src):
	re_reg = re.compile(r'(\s*reg (\[\d*\:\d*\] )?\w+)(\s*\=[^;]+)?;')
	def on_line(l):
		m = re_reg.match(l)
		if m is None: return l
		else:
			lhs, _, rhs = m.groups()
			if rhs is None:
				return lhs + " /*verilator public*/;"
			else:
				return lhs + " /*verilator public*/ " + rhs + ";"
	return '\n'.join(on_line(line) for line in src.split('\n'))


mod_dir = os.path.dirname(os.path.realpath(__file__))

def compile_sim(top: Module, cwd):
	# generate Verilator simulator
	require_verilator()
	cpp_top_file = os.path.abspath(os.path.join(mod_dir, '..', 'verilator', 'top.cpp'))
	assert os.path.isfile(cpp_top_file), f"Not found: {cpp_top_file}"
	with open(cpp_top_file) as ff:
		cpp_top = ff.read()

	header = top_hpp(top)

	# patch verilog in order to make registers accessible from C++
	verilog_src = patch_verlog(top.verilog_src)

	# compile
	with open(os.path.join(cwd, "top.hpp"), 'w') as ff:
		ff.write(header)
	with open(os.path.join(cwd, "top.cpp"), 'w') as ff:
		ff.write(cpp_top)
	with open(os.path.join(cwd, f"{top.name}.v"), 'w') as ff:
		ff.write(verilog_src)
	subprocess.run(f"verilator --cc -Wno-fatal -Wno-width -O1 {top.name}.v --trace --exe top.cpp", stderr=subprocess.PIPE, stdout=subprocess.PIPE, cwd=cwd, check=True, shell=True)
	subprocess.run(f"make -j -C obj_dir/ -f V{top.name}.mk V{top.name}", stderr=subprocess.PIPE, stdout=subprocess.PIPE, cwd=cwd, check=True, shell=True)
	return os.path.join(f"obj_dir/V{top.name}")

def make_sim_script(top: Module, m: Model):
	script = []

	# initialize register state
	registers = [st.name for st in top.state.values() if not isinstance(st, ArraySignal)]
	script += [f"set {rr} {m.data[0][m.indices[rr]]}" for rr in registers]

	# step through cycles
	clk = find_clock(top)
	inputs = [ii for ii in top.inputs.keys() if ii != clk and not ii.startswith('__')]
	for cycle in m.data:
		script += [f"set {ii} {cycle[m.indices[ii]]}" for ii in inputs]
		script += ["step"]

	return script + ["exit"]

def simulate(top: Module, m: Model, filename: str):
	cwd = tempfile.mkdtemp()
	sim = compile_sim(top, cwd=cwd)
	with open(os.path.join(cwd, 'script'), 'w') as ff:
		ff.write('\n'.join(make_sim_script(top, m)) + '\n')
	sim_path = os.path.join(cwd, sim)
	script_path = os.path.join(cwd, 'script')

	# generate vcd
	subprocess.run(f"cat script | {sim_path}", cwd=cwd, check=True, shell=True)
	vcd = os.path.join(cwd, 'dump.vcd')
	assert os.path.isfile(vcd)

	# move vcd to filename
	shutil.move(src=vcd, dst=filename)

	# remove tempdir
	shutil.rmtree(cwd)



